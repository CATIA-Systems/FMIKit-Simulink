/*****************************************************************
 *  Copyright (c) Dassault Systemes. All rights reserved.        *
 *  This file is part of FMIKit. See LICENSE.txt in the project  *
 *  root for license information.                                *
 *****************************************************************/

/*
-----------------------------------------------------------
	Implementation of FMI 2.0 on top of C code
	generated by Simulink Coder S-function target.
-----------------------------------------------------------
*/

#include "fmi.h"
#include "fmi/fmi2Functions.h"	/* Official FMI 2.0 header */

/* Model status */
typedef enum {
	modelInstantiated,
	modelInitializationMode,
	modelEventMode,
	modelContinuousTimeMode,
	modelTerminated
} ModelStatus;

/* Model data structure */
typedef struct {
	fmi2String instanceName;
	fmi2Boolean loggingOn;
	SimStruct* S;
	real_T* dX;
	real_T* oldZC;
	int_T* numSampleHits;
	int_T fixed_in_minor_step_offset_tid;
	real_T nextHit_tid0;
	void** inputs;
	void** outputs;
	void** parameters;
	void** blockoutputs;
	void** dwork;
	const fmi2CallbackFunctions* functions;
	fmi2Real lastGetTime;
	fmi2Boolean shouldRecompute;
	fmi2Boolean isCoSim;
	fmi2Boolean isDiscrete;
	fmi2Boolean hasEnteredContMode;
	fmi2Real time;
	fmi2Real nbrSolverSteps;
	fmi2EventInfo eventInfo;
	ModelStatus status;
#if defined(_MSC_VER)
	HINSTANCE* mexHandles;
#else
	void** mexHandles;
#endif
	fmi2Real* inputDerivatives;
	fmi2Real derivativeTime;
} Model;


/* -------------- Macro to check if initialized -------------- */

#define CHECK_INITIALIZED(model, label)                                        \
	if (model->status <= modelInitializationMode) {                             \
        logger(model, model->instanceName, fmi2Warning, "",                        \
			label": model is not initialized\n");                                \
		return fmi2Warning;                                                        \
	}

/* ------------- Macro for unsupported function -------------- */

#define FMI_UNSUPPORTED(label)						\
	Model* model = (Model*) c;					\
	logger(model, model->instanceName, fmi2Warning, "", "fmi2"#label": Currently not supported for FMI S-function\n");\
	return fmi2Warning


/* ------------------ Local help functions ------------------- */

fmi2CallbackAllocateMemory allocateMemory = NULL;

/* FMI memory allocation with zero initialization */
void* allocateMemory0(size_t nobj, size_t size);
/* logger wrapper for handling of enabled/disabled logging */
static void logger(fmi2Component c, fmi2String instanceName, fmi2Status status,
				   fmi2String category, fmi2String message, ...);
static fmi2String strDup(const fmi2CallbackFunctions *functions, fmi2String s);

/* --------- Allocation and destruction of SimStruct --------- */
static SimStruct *CreateSimStructForFMI(fmi2String instanceName);
static void allocateSimStructVectors(Model* m);
static void setSampleStartValues(Model* m);
static void resetSimStructVectors(SimStruct *S);
static void FreeSimStruct(SimStruct* S, const fmi2CallbackFunctions* functions);

/* ------------------ ODE solver functions ------------------- */
extern void rt_CreateIntegrationData(SimStruct *S);
extern void rt_DestroyIntegrationData(SimStruct *S);
extern void rt_UpdateContinuousStates(SimStruct *S);
const char *RT_MEMORY_ALLOCATION_ERROR = "Error when allocating SimStruct solver data.";
/* Empty callback for use as mdlProjection in ODE solver */
void mdlNoOpFunc(SimStruct *S)
{
	return;
}

extern void rt_InitInfAndNaN(size_t realSize);

/* Globals used for child S-functions */
Model* currentModel = NULL;
const char* _SFCN_FMI_MATLAB_BIN = NULL;

/* -----------------------------------------------------------
   ----------------- FMI function definitions ----------------
   ----------------------------------------------------------- */

/***************** Common functions *****************/

const char* fmi2GetTypesPlatform()
{
	return fmi2TypesPlatform;
}

const char* fmi2GetVersion()
{
	return fmi2Version;
}

fmi2Status fmi2SetDebugLogging(fmi2Component c, fmi2Boolean loggingOn, size_t nCategories, const fmi2String categories[])
{
	Model* model = (Model*) c;
	model->loggingOn = loggingOn;
	/* Categories currently not supported */
	return fmi2OK;
}

int LoadMEXAndDependencies(Model* model);
void fmi2FreeInstance(fmi2Component c);

fmi2Component fmi2Instantiate(fmi2String	instanceName,
								fmi2Type	fmuType,
								fmi2String	GUID,
								fmi2String	fmuResourceLocation,
								const fmi2CallbackFunctions* functions,
								fmi2Boolean	visible,
								fmi2Boolean	loggingOn)
{
	Model* model;

	/* Set global memory allocation function */
	if (allocateMemory == NULL) {
		allocateMemory = functions->allocateMemory;
	}

	model = (Model*) allocateMemory0(1, sizeof(Model));
	if (model == NULL) {
		goto fail;
	}

	/* The following arguments are ignored: fmuResourceLocation, visible */

	model->functions = functions;

	/* verify GUID */
	if (strcmp(GUID, GUIDString) != 0) {
		logger(model, instanceName, fmi2Error, "", "Invalid GUID: %s, expected %s\n", GUID, GUIDString);
		functions->freeMemory(model);
		return NULL;
	}

	model->instanceName = strDup(functions, instanceName);
	if (model->instanceName == NULL) {
		goto fail;
	}

	model->loggingOn = loggingOn;
	model->shouldRecompute = fmi2False;
	model->time = 0.0;
	model->nbrSolverSteps = 0.0;
	model->isDiscrete = fmi2False;
	model->isCoSim = fmi2False;
	model->hasEnteredContMode = fmi2False;
	if (fmuType == fmi2CoSimulation) {
		model->isCoSim = fmi2True;
		if (functions->stepFinished != NULL) {
			logger(model, model->instanceName, fmi2Warning, "", "fmi2Instantiate: Callback function stepFinished != NULL but asynchronous fmi2DoStep is not supported\n");
		}
	}

	if (SFCN_FMI_LOAD_MEX) {
#if defined(_MSC_VER)
		model->mexHandles = (HINSTANCE*) allocateMemory0(SFCN_FMI_NBR_MEX+1, sizeof(HINSTANCE));
#else
		model->mexHandles = (void**) allocateMemory0(SFCN_FMI_NBR_MEX+1, sizeof(void*));
#endif
		/* Handle loading of MATLAB binaries and binary MEX S-functions */
		if (!LoadMEXAndDependencies(model)) {
			goto fail;
		}
#if defined(_MSC_VER)
		SetDllDirectory(0);
#endif
	}
	if (SFCN_FMI_NBR_MEX > 0) {
		currentModel = model;
	}

	model->S = CreateSimStructForFMI(model->instanceName);
	if (model->S == NULL) {
		goto fail;
	}

	/* Register model callback functions in Simstruct */
	sfcn_fmi_registerMdlCallbacks_(model->S);

	/* Initialize sizes and create vectors */
	sfcnInitializeSizes(model->S);
	allocateSimStructVectors(model);

	/* Create solver data and ZC vector */
	rt_CreateIntegrationData(model->S);
	model->S->mdlInfo->solverInfo->zcSignalVector  = (real_T*) allocateMemory0(SFCN_FMI_ZC_LENGTH+1, sizeof(real_T));
	model->S->states.nonsampledZCs     = model->S->mdlInfo->solverInfo->zcSignalVector;
	/* Register model callback for ODE solver */
	sfcn_fmi_registerRTModelCallbacks_(model->S);

	/* Initialize sample times and sample flags */
	sfcnInitializeSampleTimes(model->S);
	setSampleStartValues(model);

	/* non-finites */
	rt_InitInfAndNaN(sizeof(real_T));
	/* Create and initialize global tunable parameters */
	sfcn_fmi_mxGlobalTunable_(model->S, 1, 0);
	/* Call mdlStart */
	if (ssGetmdlStart(model->S) != NULL) {
		sfcnStart(model->S);
	}

	/* Allocate model vectors */
	model->oldZC = (real_T*) allocateMemory0(SFCN_FMI_ZC_LENGTH+1, sizeof(real_T));
	model->numSampleHits = (int_T*) allocateMemory0(model->S->sizes.numSampleTimes+1, sizeof(int_T));
	model->inputs = (void**) allocateMemory0(SFCN_FMI_NBR_INPUTS+1, sizeof(void*));
	model->outputs = (void**) allocateMemory0(SFCN_FMI_NBR_OUTPUTS+1, sizeof(void*));
	model->parameters = (void**) allocateMemory0(SFCN_FMI_NBR_PARAMS+1, sizeof(void*));
	model->blockoutputs = (void**) allocateMemory0(SFCN_FMI_NBR_BLOCKIO+1, sizeof(void*));
	model->dwork = (void**) allocateMemory0(SFCN_FMI_NBR_DWORK+1, sizeof(void*));
	model->inputDerivatives = (fmi2Real*) allocateMemory0(SFCN_FMI_NBR_INPUTS+1, sizeof(fmi2Real));

	/* Assign variable pointers for use in fmiSetReal and fmiGetReal */
	sfcn_fmi_assignInputs_(model->S, model->inputs);
	sfcn_fmi_assignOutputs_(model->S, model->outputs);
	sfcn_fmi_assignParameters_(model->S, model->parameters);	/* Also allocates parameter struct for model instance and stores in UserData */
	sfcn_fmi_assignBlockOutputs_(model->S, model->blockoutputs);
	sfcn_fmi_assignDWork_(model->S, model->dwork);

	/* Check Simstruct error status and stop requested */
	if ((ssGetErrorStatus(model->S) != NULL) || (ssGetStopRequested(model->S) != 0)) {
		goto fail;
	}

	model->status = modelInstantiated;

	logger(model, instanceName, fmi2OK, "", "Instantiation succeeded\n");
	return model;

fail:
	if (model != NULL) {
		fmi2String iName = instanceName != NULL ? instanceName : "";
		if (model->S != NULL) {
			if ((ssGetErrorStatus(model->S) != NULL) || (ssGetStopRequested(model->S) != 0)) {
				if (ssGetStopRequested(model->S) != 0) {
					logger(model, iName, fmi2Error, "",
						"Stop requested by S-function!\n");
				}
				if (ssGetErrorStatus(model->S) != NULL) {
					logger(model, iName, fmi2Error, "",
						"Error reported by S-function: %s\n", ssGetErrorStatus(model->S));
				}
				fmi2FreeInstance(model);
				return NULL;
			}
		}
		logger(model, iName, fmi2Fatal, "",
			"Instantiation failed due to problems with memory allocation or dynamic loading.\n");
		fmi2FreeInstance(model);
	}
	return NULL;
}

void fmi2FreeInstance(fmi2Component c)
{
	Model* model = (Model*) c;
	void* paramP;
	int i;

	if (model == NULL) {
		return;
	}

	assert(model->instanceName != NULL);

	logger(model, model->instanceName, fmi2OK, "", "Freeing instance\n");

	if (model->S != NULL) {
		if (ssGetUserData(model->S) != NULL ) {
			if (SFCN_FMI_NBR_PARAMS > 0) {
				/* Free dynamically allocated parameters for this instance */
				paramP = sfcn_fmi_getParametersP_(model->S);
				sfcn_fmi_FREE(paramP, model->functions->freeMemory);
			}
		}
		/* Call mdlTerminate here, since that clears S-function Userdata */
		sfcnTerminate(model->S);
	}

	if (SFCN_FMI_LOAD_MEX) {
		for (i=0; i<SFCN_FMI_NBR_MEX; i++) {
#if defined(_MSC_VER)
			FreeLibrary(model->mexHandles[i]);
#else
			dlclose(model->mexHandles[i]);
#endif
		}
#if defined(_MSC_VER)
		SetDllDirectory(0);
#endif
		sfcn_fmi_FREE(_SFCN_FMI_MATLAB_BIN, model->functions->freeMemory);
	}

	FreeSimStruct(model->S, model->functions);
	sfcn_fmi_FREE(model->instanceName, model->functions->freeMemory);
	sfcn_fmi_FREE(model->dX, model->functions->freeMemory);
	sfcn_fmi_FREE(model->oldZC, model->functions->freeMemory);
	sfcn_fmi_FREE(model->numSampleHits, model->functions->freeMemory);
	sfcn_fmi_FREE(model->inputs, model->functions->freeMemory);
	sfcn_fmi_FREE(model->outputs, model->functions->freeMemory);
	sfcn_fmi_FREE(model->parameters, model->functions->freeMemory);
	sfcn_fmi_FREE(model->blockoutputs, model->functions->freeMemory);
	sfcn_fmi_FREE(model->dwork, model->functions->freeMemory);
	sfcn_fmi_FREE(model->mexHandles, model->functions->freeMemory);
	sfcn_fmi_FREE(model->inputDerivatives, model->functions->freeMemory);
	sfcn_fmi_FREE(model, model->functions->freeMemory);

	/* Reset global memory allocation function */
	allocateMemory = NULL;
}

fmi2Status fmi2SetTime(fmi2Component c, fmi2Real time);
fmi2Status fmi2SetupExperiment(fmi2Component c,
										fmi2Boolean toleranceDefined,
										fmi2Real tolerance,
										fmi2Real startTime,
										fmi2Boolean stopTimeDefined,
										fmi2Real stopTime)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;

	/* Any supplied tolerance if toleranceDefined is not used */
	if (stopTimeDefined == fmi2True) {
		/* Provide information that stopTime will not be enforced by FMU */
		logger(model, model->instanceName, status, "", "fmi2SetupExperiment: The defined stopTime will not be enforced by the FMU\n");
	}
	if (fabs(startTime) > SFCN_FMI_EPS) {
		status = fmi2Error;
		logger(model, model->instanceName, status, "", "fmi2SetupExperiment: startTime other than 0.0 not supported\n");
	}
	return status;
}

fmi2Status fmi2NewDiscreteStates_(fmi2Component c, fmi2EventInfo* eventInfo);
fmi2Status fmi2EnterInitializationMode(fmi2Component c)
{
	Model* model = (Model*) c;

	/* Initialize continuous-time states */
	if (ssGetmdlInitializeConditions(model->S) != NULL) {
		sfcnInitializeConditions(model->S);
	}
	if (_ssGetRTWGeneratedEnable(model->S) != NULL) {
		_sfcnRTWGeneratedEnable(model->S);
	}
	/* Check Simstruct error status and stop requested */
	if ((ssGetErrorStatus(model->S) != NULL) || (ssGetStopRequested(model->S) != 0)) {
		if (ssGetStopRequested(model->S) != 0) {
			logger(model, model->instanceName, fmi2Error, "", "Stop requested by S-function!\n");
		}
		if (ssGetErrorStatus(model->S) != NULL) {
			logger(model, model->instanceName, fmi2Error, "", "Error reported by S-function: %s\n", ssGetErrorStatus(model->S));
		}
		model->status = modelInitializationMode;
		return fmi2Error;
	}

	model->S->mdlInfo->t[0] = 0.0;
	if (model->fixed_in_minor_step_offset_tid != -1) {
		model->S->mdlInfo->t[model->fixed_in_minor_step_offset_tid] = 0.0;
	}

	if (!(model->isCoSim)) {
		/* Call mdlOutputs for continuous parts */
		if (model->fixed_in_minor_step_offset_tid != -1) {
			model->S->mdlInfo->sampleHits[model->fixed_in_minor_step_offset_tid] = 1;
			if (SFCN_FMI_LOAD_MEX) {
				copyPerTaskSampleHits(model->S);
			}
		}
		sfcnOutputs(model->S,0);
		_ssSetTimeOfLastOutput(model->S,model->S->mdlInfo->t[0]);
		if (model->fixed_in_minor_step_offset_tid != -1) {
			model->S->mdlInfo->sampleHits[model->fixed_in_minor_step_offset_tid] = 0;
			if (SFCN_FMI_LOAD_MEX) {
				copyPerTaskSampleHits(model->S);
			}
		}
	}

	model->status = modelInitializationMode;

	logger(model, model->instanceName, fmi2OK, "", "Enter initialization mode\n");
	return fmi2OK;
}

fmi2Status fmi2ExitInitializationMode(fmi2Component c)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;

	model->status = modelEventMode;

	if (model->isCoSim) {
		/* Evaluate model at t=0 */
		status = fmi2NewDiscreteStates(c, &(model->eventInfo));
		if (status != fmi2OK) {
			model->status = modelInstantiated;
			return status;
		}
	}

	model->shouldRecompute = fmi2True;
	model->lastGetTime = -1.0;  /* to make sure that derivatives are computed in fmi2GetReal at t=0 */

	logger(model, model->instanceName, fmi2OK, "", "Exit initialization mode, enter event mode\n");
	return fmi2OK;
}

fmi2Status fmi2Terminate(fmi2Component c)
{
	Model* model = (Model*) c;

	if (model == NULL) {
		return fmi2OK;
	}

	logger(model, model->instanceName, fmi2OK, "", "Terminating\n");
	model->status = modelTerminated;

	return fmi2OK;
}

fmi2Status fmi2Reset(fmi2Component c)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;
	void* paramP;

	resetSimStructVectors(model->S);
	rt_DestroyIntegrationData(model->S);
	rt_CreateIntegrationData(model->S);
	setSampleStartValues(model);
	if (ssGetUserData(model->S) != NULL ) {
		if (SFCN_FMI_NBR_PARAMS > 0) {
			paramP = sfcn_fmi_getParametersP_(model->S);
			sfcn_fmi_FREE(paramP, model->functions->freeMemory);
		}
	}
	sfcnTerminate(model->S);
	if (ssGetmdlStart(model->S) != NULL) {
		sfcnStart(model->S);
	}
	if (ssGetmdlInitializeConditions(model->S) != NULL) {
		sfcnInitializeConditions(model->S);
	}
	sfcn_fmi_assignParameters_(model->S, model->parameters);
	memset(model->oldZC,			0, (SFCN_FMI_ZC_LENGTH+1)*sizeof(real_T));
	memset(model->numSampleHits,	0, (model->S->sizes.numSampleTimes+1)*sizeof(int_T));
	model->fixed_in_minor_step_offset_tid = 0;
	model->nextHit_tid0 = 0.0;
	model->lastGetTime = -1.0;
	model->shouldRecompute = fmi2False;
	model->time = 0.0;
	model->nbrSolverSteps = 0.0;
	model->status = modelInstantiated;

	return status;
}

/***************** Get / Set functions/macros *****************/

static void setValueReal(const void* vPtr, int dataType, fmi2Real value)
{
	switch (dataType) {
		case SS_SINGLE:   /* real32_T  */
			*((real32_T*)vPtr) = (real32_T) value;
			break;
		default:   /* All other cases treated as real_T */
			*((real_T*)vPtr) = (real_T) value;
			break;
	}
}

static void setValueInteger(const void* vPtr, int dataType, fmi2Integer value)
{
	switch (dataType) {
		case SS_INT8:   /* int8_T  */
			*((int8_T*)vPtr) = (int8_T) value;
			break;
		case SS_UINT8:   /* uint8_T  */
			*((uint8_T*)vPtr) = (uint8_T) value;
			break;
		case SS_INT16:   /* int16_T  */
			*((int16_T*)vPtr) = (int16_T) value;
			break;
		case SS_UINT16:   /* uint16_T  */
			*((uint16_T*)vPtr) = (uint16_T) value;
			break;
		case SS_INT32:   /* int32_T  */
			*((int32_T*)vPtr) = (int32_T) value;
			break;
		case SS_UINT32:   /* uint32_T  */
			*((uint32_T*)vPtr) = (uint32_T) value;
			break;
		default:   /* All other cases treated as int32_T */
			*((int32_T*)vPtr) = (int32_T) value;
			break;
	}
}

static void setValueBoolean(const void* vPtr, int dataType, fmi2Boolean value)
{
	/* Should only be called if dataType is indeed boolean_T */
	*((boolean_T*)vPtr) = (boolean_T) value;
}

#define FMI_SET(label)												\
	Model* model = (Model*) c;												\
	size_t i;																\
    fmi2Boolean allowed = fmi2True;											\
	fmi2Boolean paramChanged = fmi2False;											\
																			\
	for (i = 0; i < nvr; i++) {												\
		const fmi2ValueReference r = vr[i];									\
		int index    = SFCN_FMI_INDEX(r);									\
		int dataType = SFCN_FMI_DATATYPE(r);								\
																			\
		switch (SFCN_FMI_CATEGORY(r)) {										\
        case SFCN_FMI_INPUT:												\
			setValue ## label(model->inputs[index], dataType, value[i]);	\
			model->shouldRecompute = fmi2True;\
			break;															\
		case SFCN_FMI_STATE:												\
			if (model->isCoSim && model->status != modelInstantiated) {\
				allowed = fmi2False;	\
			} else {\
				ssGetContStates(model->S)[index] = (real_T)value[i];			\
				model->shouldRecompute = fmi2True;\
			}\
			break;															\
		case SFCN_FMI_DERIVATIVE:\
			if (model->status == modelInstantiated) {\
				ssGetdX(model->S)[index] = (real_T)value[i];\
			} else {\
				allowed = fmi2False;			\
			}\
			break;															\
        case SFCN_FMI_BLOCKIO:												\
		    if (model->status == modelInstantiated) {					\
				setValue ## label(model->blockoutputs[index], dataType, value[i]);	\
			} else {														\
                allowed = fmi2False;											\
			}																\
			break;															\
		case SFCN_FMI_DWORK:												\
		    if (model->status == modelInstantiated) {					\
			    setValue ## label(model->dwork[index], dataType, value[i]);	\
			} else {														\
                allowed = fmi2False;											\
			}																\
			break;															\
		case SFCN_FMI_PARAMETER:											\
     		setValue ## label(model->parameters[index], dataType, value[i]);	\
			model->shouldRecompute = fmi2True;\
			paramChanged = fmi2True;\
			break;															\
        case SFCN_FMI_OUTPUT:												\
     		if (model->status == modelInstantiated) {					\
			    setValue ## label(model->outputs[index], dataType, value[i]);	\
			} else {														\
                allowed = fmi2False;											\
			}																\
			break;															\
		default:															\
	        logger(model, model->instanceName, fmi2Warning, "", "fmi2Set"#label": cannot set %u\n", r);		\
            return fmi2Warning;												\
		}																	\
		if (allowed == fmi2False) {											\
			logger(model, model->instanceName, fmi2Warning, "", "fmi2Set"#label": may not change %u at this stage\n", r);	\
			return fmi2Warning;												\
		}																	\
	}																		\
	if (paramChanged == fmi2True && SFCN_FMI_LOAD_MEX) {											\
		sfcn_fmi_copyToSFcnParams_(model->S);\
		sfcn_fmi_mxGlobalTunable_(model->S, 1, 1);\
	}\
	return fmi2OK

static fmi2Real getValueReal(const void* vPtr, int dataType)
{
	switch (dataType) {
		case SS_SINGLE:   /* real32_T  */
			return (fmi2Real) (*((real32_T*)vPtr));
		default:   /* All other cases treated as real_T */
			return (fmi2Real) (*((real_T*)vPtr));
	}
}

static fmi2Integer getValueInteger(const void* vPtr, int dataType)
{
	switch (dataType) {
		case SS_INT8:   /* int8_T  */
			return (fmi2Integer) (*((int8_T*)vPtr));
		case SS_UINT8:   /* uint8_T  */
			return (fmi2Integer) (*((uint8_T*)vPtr));
		case SS_INT16:   /* int16_T  */
			return (fmi2Integer) (*((int16_T*)vPtr));
		case SS_UINT16:   /* uint16_T  */
			return (fmi2Integer) (*((uint16_T*)vPtr));
		case SS_INT32:   /* int32_T  */
			return (fmi2Integer) (*((int32_T*)vPtr));
		case SS_UINT32:   /* uint32_T  */
			return (fmi2Integer) (*((uint32_T*)vPtr));
		default:   /* All other cases treated as int32_T */
			return (fmi2Integer) (*((int32_T*)vPtr));
	}
}

static fmi2Boolean getValueBoolean(const void* vPtr, int dataType)
{
	/* Should only be called if dataType is indeed boolean_T */
	return (fmi2Boolean) (*((boolean_T*)vPtr));
}

#define FMI_GET(label)												\
	Model* model = (Model*) c;											\
	size_t i;															\
																		\
	if (model->status == modelInstantiated) {                     \
		logger(model, model->instanceName, fmi2Warning, "", "fmi2Get"#label": Not allowed before call to fmi2EnterInitializationMode\n"); \
		return fmi2Warning;                                              \
	}																	\
																		\
	if (!model->isCoSim && !model->isDiscrete) {\
		if ((!isEqual(ssGetT(model->S), model->lastGetTime)) || model->shouldRecompute) {\
			sfcnOutputs(model->S,0);											\
			_ssSetTimeOfLastOutput(model->S,model->S->mdlInfo->t[0]);			\
			if (ssGetmdlDerivatives(model->S) != NULL) {						\
				sfcnDerivatives(model->S);										\
			}																	\
			model->S->mdlInfo->simTimeStep = MINOR_TIME_STEP;					\
			model->shouldRecompute = fmi2False;\
			model->lastGetTime = ssGetT(model->S);\
		}\
	}\
																		\
	for (i = 0; i < nvr; i++) {											\
		const fmi2ValueReference r = vr[i];								\
		int index = SFCN_FMI_INDEX(r);									\
		int dataType = SFCN_FMI_DATATYPE(r);							\
																		\
		switch (SFCN_FMI_CATEGORY(r)) {									\
        case SFCN_FMI_INPUT:											\
			value[i] = getValue ## label(model->inputs[index], dataType);	\
			break;														\
		case SFCN_FMI_STATE:											\
			value[i] = (fmi2 ## label) ssGetContStates(model->S)[index];	\
			break;														\
		case SFCN_FMI_DERIVATIVE:										\
			value[i] = (fmi2 ## label) ssGetdX(model->S)[index];			\
			break;														\
        case SFCN_FMI_BLOCKIO:											\
		    value[i] = getValue ## label(model->blockoutputs[index], dataType);	\
			break;														\
		case SFCN_FMI_DWORK:											\
		    value[i] = getValue ## label(model->dwork[index], dataType);	\
			break;														\
		case SFCN_FMI_PARAMETER:										\
     		value[i] = getValue ## label(model->parameters[index], dataType);	\
			break;														\
        case SFCN_FMI_OUTPUT:											\
     		value[i] = getValue ## label(model->outputs[index], dataType);	\
			break;														\
		default:														\
			logger(model, model->instanceName, fmi2Warning, "", "fmi2Get"#label": cannot get %u\n", r);   \
            return fmi2Warning;											\
		}																\
	}																	\
	return fmi2OK;

/* ---------------------------------------------------------------------- */

fmi2Status fmi2SetReal(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Real value[])
{
    FMI_SET(Real);
}

fmi2Status fmi2SetInteger(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Integer value[])
{
	FMI_SET(Integer);
}

fmi2Status fmi2SetBoolean(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Boolean value[])
{
	FMI_SET(Boolean);
}

fmi2Status fmi2SetString(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2String  value[])
{
	FMI_UNSUPPORTED(SetString);
}

fmi2Status fmi2GetReal(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2Real value[])
{
	FMI_GET(Real);
}

fmi2Status fmi2GetInteger(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2Integer value[])
{
	FMI_GET(Integer);
}

fmi2Status fmi2GetBoolean(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2Boolean value[])
{
	FMI_GET(Boolean);
}

fmi2Status fmi2GetString(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, fmi2String  value[])
{
	FMI_UNSUPPORTED(GetString);
}

fmi2Status fmi2GetFMUstate(fmi2Component c, fmi2FMUstate* FMUstate)
{
	FMI_UNSUPPORTED(GetFMUstate);
}

fmi2Status fmi2SetFMUstate(fmi2Component c, fmi2FMUstate FMUstate)
{
	FMI_UNSUPPORTED(SetFMUstate);
}

fmi2Status fmi2FreeFMUstate(fmi2Component c, fmi2FMUstate* FMUstate)
{
	FMI_UNSUPPORTED(FreeFMUstate);
}

fmi2Status fmi2SerializedFMUstateSize(fmi2Component c, fmi2FMUstate FMUstate, size_t* size)
{
	FMI_UNSUPPORTED(SerializedFMUstateSize);
}

fmi2Status fmi2SerializeFMUstate_     (fmi2Component c, fmi2FMUstate FMUstate, fmi2Byte serializedState[], size_t size)
{
	FMI_UNSUPPORTED(SerializeFMUstate);
}

fmi2Status fmi2DeSerializeFMUstate_   (fmi2Component c, const fmi2Byte serializedState[], size_t size, fmi2FMUstate* FMUstate)
{
	FMI_UNSUPPORTED(DeSerializeFMUstate);
}

fmi2Status fmi2GetDirectionalDerivative(fmi2Component c, const fmi2ValueReference vUnknown_ref[], size_t nUnknown,
                                                         const fmi2ValueReference vKnown_ref[], size_t nKnown,
                                                         const fmi2Real dvKnown[],
														       fmi2Real dvUnknown[])
{
	FMI_UNSUPPORTED(GetDirectionalDerivative);
}

/***************** Model Exchange functions *****************/

fmi2Status fmi2EnterEventMode(fmi2Component c)
{
	Model* model = (Model*) c;

	CHECK_INITIALIZED(model, "fmi2EnterEventMode");

	if (model->status != modelContinuousTimeMode) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2EnterEventMode: May only be called in continuous-time mode\n");
		return fmi2Warning;
	}

	logger(model, model->instanceName, fmi2OK, "", "Enter event mode at time = %.16f\n", ssGetT(model->S));
	model->status = modelEventMode;
	return fmi2OK;
}

fmi2Status fmi2NewDiscreteStates(fmi2Component c, fmi2EventInfo* eventInfo)
{
	int i;
	Model* model = (Model*) c;
	fmi2Real nextT;
	real_T compareVal;
	int_T sampleHit = 0;

	CHECK_INITIALIZED(model, "fmi2NewDiscreteStates");

#if defined(SFCN_FMI_VERBOSITY)
	logger(model, model->instanceName, fmi2OK, "", "fmi2NewDiscreteStates: Call at time = %.16f\n", ssGetT(model->S));
#endif

	/* Set sample hits for discrete systems */
	for (i=0;i<model->S->sizes.numSampleTimes;i++) {
		if (model->S->stInfo.sampleTimes[i] > SFCN_FMI_EPS) { /* Discrete sample time */
			if (i==0) {
				compareVal = model->nextHit_tid0; /* Purely discrete, use stored hit time for task 0 */
				model->isDiscrete = fmi2True;
			} else {
				compareVal = model->S->mdlInfo->t[i];
			}
			if (isEqual(ssGetT(model->S), compareVal)) {
				sampleHit = 1;
				model->S->mdlInfo->sampleHits[i] = 1;
#if defined(SFCN_FMI_VERBOSITY)
				logger(model, model->instanceName, fmi2OK, "", "fmi2NewDiscreteStates: Sample hit for task %d\n", i);
#endif
				/* Update time for next sample hit */
				model->numSampleHits[i]++;
			}
		}
	}
	/* Set sample hit for continuous sample time with FIXED_IN_MINOR_STEP_OFFSET */
	if (model->fixed_in_minor_step_offset_tid != -1) {
		/* Except first call after initialization */
		model->S->mdlInfo->sampleHits[model->fixed_in_minor_step_offset_tid] = 0;
		if (model->hasEnteredContMode) {
			model->S->mdlInfo->sampleHits[model->fixed_in_minor_step_offset_tid] = 1;
		}
	}
	if (SFCN_FMI_LOAD_MEX) {
		copyPerTaskSampleHits(model->S);
	}

	if (!(model->isDiscrete && !sampleHit)) { /* Do not evaluate model if purely discrete and no sample hit */
		model->S->mdlInfo->simTimeStep = MAJOR_TIME_STEP;
		sfcnOutputs(model->S, 0);
		_ssSetTimeOfLastOutput(model->S,model->S->mdlInfo->t[0]);
		if (ssGetmdlUpdate(model->S) != NULL) {
#if defined(SFCN_FMI_VERBOSITY)
			logger(model, model->instanceName, fmi2OK, "", "fmi2NewDiscreteStates: Calling mdlUpdate at time %.16f\n", ssGetT(model->S));
#endif
			sfcnUpdate(model->S, 0);
		}
		model->S->mdlInfo->simTimeStep = MINOR_TIME_STEP;
	}

	/* Find next time event and reset sample hits */
	nextT = SFCN_FMI_MAX_TIME;
	for (i=0;i<model->S->sizes.numSampleTimes;i++) {
		if (model->S->stInfo.sampleTimes[i] > SFCN_FMI_EPS) { /* Discrete sample time */
			compareVal = model->S->stInfo.offsetTimes[i] + model->numSampleHits[i]*model->S->stInfo.sampleTimes[i];
			if (i==0) {
				/* Store, will be overwritten by fmiSetTime */
				model->nextHit_tid0 = compareVal;
			} else {
				model->S->mdlInfo->t[i] = compareVal;
			}
			if (compareVal < nextT) {
				nextT = compareVal;
			}
			model->S->mdlInfo->sampleHits[i] = 0;
		}
	}
	if (model->fixed_in_minor_step_offset_tid != -1) {
		model->S->mdlInfo->sampleHits[model->fixed_in_minor_step_offset_tid] = 0;
	}
	if (SFCN_FMI_LOAD_MEX) {
		copyPerTaskSampleHits(model->S);
	}
	/* Only treat zero crossing functions for model exchange */
	if (!(model->isCoSim)) {
		if (model->S->modelMethods.sFcn.mdlZeroCrossings != NULL) {
			sfcnZeroCrossings(model->S);
		}
		for (i=0;i<SFCN_FMI_ZC_LENGTH;i++) {
			/* Store current ZC values at event */
			model->oldZC[i] = model->S->mdlInfo->solverInfo->zcSignalVector[i];
		}
	}
	model->shouldRecompute = fmi2True;

	eventInfo->newDiscreteStatesNeeded				= fmi2False;
    eventInfo->terminateSimulation					= fmi2False;
    eventInfo->nominalsOfContinuousStatesChanged	= fmi2False;
    eventInfo->valuesOfContinuousStatesChanged		= fmi2False;
#if defined(MATLAB_R2017b_)
	if (model->S->mdlInfo->mdlFlags.blockStateForSolverChangedAtMajorStep) {
		model->S->mdlInfo->mdlFlags.blockStateForSolverChangedAtMajorStep = 0U;
#else
	if (model->S->mdlInfo->solverNeedsReset == 1) {
		_ssClearSolverNeedsReset(model->S);
#endif
		eventInfo->valuesOfContinuousStatesChanged = fmi2True;
#if defined(SFCN_FMI_VERBOSITY)
		logger(model, model->instanceName, fmi2OK, "", "fmi2NewDiscreteStates: State values changed at time %.16f\n", ssGetT(model->S));
#endif
	}
	eventInfo->nextEventTimeDefined = (nextT < SFCN_FMI_MAX_TIME);
	eventInfo->nextEventTime = nextT;

#if defined(SFCN_FMI_VERBOSITY)
		logger(model, model->instanceName, fmi2OK, "", "fmi2NewDiscreteStates: Event handled at time = %.16f, next event time at %.16f\n", ssGetT(model->S), nextT);
#endif
	return fmi2OK;
}

fmi2Status fmi2EnterContinuousTimeMode(fmi2Component c)
{
	Model* model = (Model*) c;

	CHECK_INITIALIZED(model, "fmi2EnterContinuousTimeMode");

	if (model->status != modelEventMode) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2EnterContinuousTimeMode: May only be called in event mode\n");
		return fmi2Warning;
	}

	logger(model, model->instanceName, fmi2OK, "", "Enter continuous-time mode at time = %.16f\n", ssGetT(model->S));
	model->hasEnteredContMode = fmi2True;
	model->status = modelContinuousTimeMode;
	return fmi2OK;
}

fmi2Status fmi2CompletedIntegratorStep(fmi2Component c, fmi2Boolean noSetFMUStatePriorToCurrentPoint,
										fmi2Boolean* enterEventMode, fmi2Boolean* terminateSimulation)
{
	int i;
	real_T currZC_i;
	Model* model = (Model*) c;
	int rising  = 0;
	int falling = 0;

	CHECK_INITIALIZED(model, "fmi2CompletedIntegratorStep");

#if defined(SFCN_FMI_VERBOSITY)
	logger(model, model->instanceName, fmi2OK, "", "fmi2CompletedIntegratorStep: Call at time %.16f\n", ssGetT(model->S));
#endif

	/* Evaluate zero-crossing functions */
	if (model->S->modelMethods.sFcn.mdlZeroCrossings != NULL) {
		sfcnZeroCrossings(model->S);
	}
	/* Check for zero crossings */
	for (i=0;i<SFCN_FMI_ZC_LENGTH;i++) {
		currZC_i = model->S->mdlInfo->solverInfo->zcSignalVector[i];
		rising  = ((model->oldZC[i] < 0.0) && (currZC_i >= 0.0)) || ((model->oldZC[i] == 0.0) && (currZC_i > 0.0));
		falling = ((model->oldZC[i] > 0.0) && (currZC_i <= 0.0)) || ((model->oldZC[i] == 0.0) && (currZC_i < 0.0));
#if defined(SFCN_FMI_VERBOSITY)
		logger(model, model->instanceName, fmi2OK, "", "fmi2CompletedIntegratorStep: oldZC[%d] = %.16f ; currZC[%d] = %.16f\n", i, model->oldZC[i], i, currZC_i);
#endif
		if (rising || falling) {
			break;
		}
	}
	/* Store current zero-crossing values at step */
	for (i=0;i<SFCN_FMI_ZC_LENGTH;i++) {
		model->oldZC[i] = model->S->mdlInfo->solverInfo->zcSignalVector[i];
	}

	/* Do not set major time step if we stepped passed a zero crossing
	   Will be a major time step in EventMode */
	if (!(rising || falling) && !model->isDiscrete) {
		model->S->mdlInfo->simTimeStep = MAJOR_TIME_STEP;
		/* Update continuous task with FIXED_IN_MINOR_STEP_OFFSET */
		if (model->fixed_in_minor_step_offset_tid != -1) {
			model->S->mdlInfo->sampleHits[model->fixed_in_minor_step_offset_tid] = 1;
			if (SFCN_FMI_LOAD_MEX) {
				copyPerTaskSampleHits(model->S);
			}
		}
		sfcnOutputs(model->S, 0);
		_ssSetTimeOfLastOutput(model->S,model->S->mdlInfo->t[0]);
		if (ssGetmdlUpdate(model->S) != NULL) {
#if defined(SFCN_FMI_VERBOSITY)
			logger(model, model->instanceName, fmi2OK, "", "fmi2CompletedIntegratorStep: Calling mdlUpdate at time %.16f\n", ssGetT(model->S));
#endif
			sfcnUpdate(model->S, 0);
		}
		if (model->fixed_in_minor_step_offset_tid != -1) {
			model->S->mdlInfo->sampleHits[model->fixed_in_minor_step_offset_tid] = 0;
			if (SFCN_FMI_LOAD_MEX) {
				copyPerTaskSampleHits(model->S);
			}
		}
		model->S->mdlInfo->simTimeStep = MINOR_TIME_STEP;
	}
	*enterEventMode = fmi2False;
	*terminateSimulation = fmi2False;
	model->shouldRecompute=fmi2True;

	return fmi2OK;
}

fmi2Status fmi2SetTime(fmi2Component c, fmi2Real time)
{
	Model*  model = (Model*) c;

	model->S->mdlInfo->t[0] = time;
	if (model->fixed_in_minor_step_offset_tid != -1) {
		model->S->mdlInfo->t[model->fixed_in_minor_step_offset_tid] = time;
	}
	return fmi2OK;
}

fmi2Status fmi2SetContinuousStates(fmi2Component c, const fmi2Real x[], size_t nx)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;

	int_T nxS = ssGetNumContStates(model->S);
	if (((int_T) nx) != nxS) {
		status = fmi2Warning;
		logger(model, model->instanceName, status, "",
			"fmi2SetContinuousStates: argument nx = %u is incorrect, should be %u\n", nx, nxS);
		if (((int_T) nx) > nxS) {
			/* truncate */
			nx = nxS;
		}
	}
	memcpy(ssGetContStates(model->S), x, nx * sizeof(fmi2Real));
	model->shouldRecompute=fmi2True;

	return status;
}

fmi2Status fmi2GetDerivatives(fmi2Component c, fmi2Real derivatives[], size_t nx)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;
	int_T nxS;

	if (model->status == modelInstantiated) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2GetDerivatives: Not allowed before call to fmi2EnterInitializationMode\n");
		return fmi2Warning;
	}

	nxS = ssGetNumContStates(model->S);
	if (((int_T) nx) != nxS) {
		status = fmi2Warning;
		logger(model, model->instanceName, status, "",
			"fmi2GetDerivatives: argument nx = %u is incorrect, should be %u\n", nx, nxS);
		if (((int_T) nx) > nxS) {
			/* truncate */
			nx = nxS;
		}
	}

	sfcnOutputs(model->S,0);
	_ssSetTimeOfLastOutput(model->S,model->S->mdlInfo->t[0]);
	if (ssGetmdlDerivatives(model->S) != NULL) {
		sfcnDerivatives(model->S);
		memcpy(derivatives, ssGetdX(model->S), nx * sizeof(fmi2Real));
	}
	model->S->mdlInfo->simTimeStep = MINOR_TIME_STEP;
	return status;
}

fmi2Status fmi2GetEventIndicators(fmi2Component c, fmi2Real eventIndicators[], size_t ni)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;
	int_T nzS;

	if (model->status == modelInstantiated) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2GetEventIndicators: Not allowed before call to fmi2EnterInitializationMode\n");
		return fmi2Warning;
	}

	nzS = SFCN_FMI_ZC_LENGTH;
	if (((int_T) ni) != nzS) {
		status = fmi2Warning;
		logger(model, model->instanceName, status, "",
			"fmi2GetEventIndicators: argument ni = %u is incorrect, should be %u\n", ni, nzS);
		if (((int_T) ni) > nzS) {
			/* truncate */
			ni = nzS;
		}
	}

	sfcnOutputs(model->S,0);
	_ssSetTimeOfLastOutput(model->S,model->S->mdlInfo->t[0]);
	if (model->S->modelMethods.sFcn.mdlZeroCrossings != NULL) {
		sfcnZeroCrossings(model->S);
		memcpy(eventIndicators, model->S->mdlInfo->solverInfo->zcSignalVector, ni * sizeof(fmi2Real));
	}
	model->S->mdlInfo->simTimeStep = MINOR_TIME_STEP;
	return status;
}

fmi2Status fmi2GetContinuousStates(fmi2Component c, fmi2Real states[], size_t nx)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;
	int_T nxS;

	if (model->status == modelInstantiated) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2GetContinuousStates: Not allowed before call to fmi2EnterInitializationMode\n");
		return fmi2Warning;
	}

	nxS = ssGetNumContStates(model->S);
	if (((int_T) nx) != nxS) {
		status = fmi2Warning;
		logger(model, model->instanceName, status, "",
			"fmi2GetContinuousStates: argument nx = %u is incorrect, should be %u\n", nx, nxS);
		if (((int_T) nx) > nxS) {
			/* truncate */
			nx = nxS;
		}
	}

	memcpy(states, ssGetContStates(model->S), nx * sizeof(fmi2Real));
	return status;
}

fmi2Status fmi2GetNominalsOfContinuousStates(fmi2Component c, fmi2Real x_nominal[], size_t nx)
{
	unsigned int i;
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;

	int_T nxS = ssGetNumContStates(model->S);
	if (((int_T) nx) != nxS) {
		status = fmi2Warning;
		logger(model, model->instanceName, status, "",
			"fmi2GetNominalContinuousStates: argument nx = %u is incorrect, should be %u\n", nx, nxS);
		if (((int_T) nx) > nxS) {
			/* truncate */
			nx = nxS;
		}
	}

	for (i=0;i<nx;i++) {
		x_nominal[i] = 1.0; /* Unknown nominal */
	}
	return status;
}


/***************** Co-Simulation functions *****************/

fmi2Status fmi2SetRealInputDerivatives(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Integer order[], const fmi2Real value[])
{
	Model* model = (Model*) c;
	size_t i;

	if (model->status <= modelInitializationMode) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2SetRealInputDerivatives: Slave is not initialized\n");
		return fmi2Warning;
	}
	if (nvr == 0 || nvr > SFCN_FMI_NBR_INPUTS) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2SetRealInputDerivatives: Invalid nvr = %d (number of inputs = %d)\n", nvr, SFCN_FMI_NBR_INPUTS);
		return fmi2Warning;
	}
	for (i = 0; i < nvr; i++) {
		const fmi2ValueReference r = vr[i];
		int index    = SFCN_FMI_INDEX(r);
		int dataType = SFCN_FMI_DATATYPE(r);

		if (order[i] == 1) {
			switch (SFCN_FMI_CATEGORY(r)) {
			case SFCN_FMI_INPUT:
				if (dataType == SS_DOUBLE) {
					/* Non-zero derivatives only for double-valued real inputs */
					model->inputDerivatives[index] = value[i];
#if defined(SFCN_FMI_VERBOSITY)
					logger(model, model->instanceName, fmi2OK, "", "fmi2SetRealInputDerivatives: Setting derivative at input #%d to %.16f at time = %.16f.\n", i, value[i], model->time);
#endif
				}
				break;
			default:
				logger(model, model->instanceName, fmi2Warning, "", "fmi2SetRealInputDerivatives: variable is not input");
				return fmi2Warning;
			}
		} else {
			logger(model, model->instanceName, fmi2Warning, "", "fmi2SetRealInputDerivatives: derivative order %d is not supported", order[i]);
			return fmi2Warning;
		}
	}
	model->derivativeTime = model->time;

	return fmi2OK;
}

fmi2Status fmi2GetRealOutputDerivatives(fmi2Component c, const fmi2ValueReference vr[], size_t nvr, const fmi2Integer order[], fmi2Real value[])
{
	Model* model = (Model*) c;
	size_t i;

	if (model->status <= modelInitializationMode) {
        logger(model, model->instanceName, fmi2Warning, "", "fmi2GetRealOutputDerivatives: Slave is not initialized\n");
		return fmi2Warning;
	}
	if (nvr == 0 || nvr > SFCN_FMI_NBR_OUTPUTS) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2GetRealOutputDerivatives: Invalid nvr = %d (number of outputs = %d)\n", nvr, SFCN_FMI_NBR_OUTPUTS);
		return fmi2Warning;
	}
	for (i = 0; i < nvr; i++) {
		if (order[i] > 0) {
			value[i] = 0.0;
		} else {
			logger(model, model->instanceName, fmi2Warning, "", "fmi2GetRealOutputDerivatives: Derivative order 0 is not allowed\n");
			return fmi2Warning;
		}
	}
	return fmi2OK;
}

static void extrapolateInputs(Model* model, fmi2Real t)
{
	size_t i;
	fmi2Real dt = (t - model->derivativeTime);
	for (i = 0; i < SFCN_FMI_NBR_INPUTS; i++) {
		if (model->inputDerivatives[i] != 0.0) {
			*((real_T*)(model->inputs[i])) += model->inputDerivatives[i] * dt;
#if defined(SFCN_FMI_VERBOSITY)
			logger(model, model->instanceName, fmi2OK, "", "Extrapolated input #%d to value = %.16f\n", i, *((real_T*)(model->inputs[i])));
#endif
		}
	}
	model->derivativeTime = t;
}

fmi2Status fmi2DoStep(fmi2Component c, fmi2Real currentCommunicationPoint, fmi2Real communicationStepSize, fmi2Boolean noSetFMUStatePriorToCurrentPoint)
{
	Model* model = (Model*) c;
	fmi2Status status = fmi2OK;
	fmi2Real lastSolverTime, nextSolverTime;
	fmi2Real endStepTime;

	if (model->status <= modelInitializationMode) {
        logger(model, model->instanceName, fmi2Warning, "", "fmi2DoStep: Slave is not initialized\n");
		return fmi2Warning;
	}
	if (model->status == modelTerminated) {
        logger(model, model->instanceName, fmi2Warning, "", "fmi2DoStep: Slave terminated in previous step\n");
		return fmi2Warning;
	}
	if (!isEqual(model->time, currentCommunicationPoint)) {
		logger(model, model->instanceName, fmi2Warning, "", "fmi2DoStep: Invalid currentCommunicationPoint = %.16f, expected %.16f\n", currentCommunicationPoint, model->time);
		return fmi2Warning;
	}
	model->S->mdlInfo->simTimeStep = MAJOR_TIME_STEP;
	if (fabs(communicationStepSize) < SFCN_FMI_EPS) {
		/* Zero step size; External event iteration, just recompute outputs */
		sfcnOutputs(model->S, 0);
		return fmi2OK;
	}
	endStepTime = currentCommunicationPoint + communicationStepSize;
	lastSolverTime = model->nbrSolverSteps*SFCN_FMI_FIXED_STEP_SIZE;
	nextSolverTime = (model->nbrSolverSteps+1.0)*SFCN_FMI_FIXED_STEP_SIZE;
	while ( (nextSolverTime < endStepTime) || isEqual(nextSolverTime, endStepTime) ) {
#if defined(SFCN_FMI_VERBOSITY)
		logger(model, model->instanceName, fmi2OK, "", "fmi2DoStep: Internal solver step from %.16f to %.16f\n", lastSolverTime, nextSolverTime);
#endif
		/* Set time for state update */
		fmi2SetTime(c, lastSolverTime);
		/* Update continuous-time states */
		if (ssGetNumContStates(model->S) > 0) {
#if defined(SFCN_FMI_VERBOSITY)
			logger(model, model->instanceName, fmi2OK, "", "fmi2DoStep: Updating continuous states at time = %.16f.\n", model->S->mdlInfo->t[0]);
#endif
			/* Set ODE solver stop time */
			_ssSetSolverStopTime(model->S, nextSolverTime);
			/* Update states */
			rt_UpdateContinuousStates(model->S);
		}
		/* Set time for output calculations */
		fmi2SetTime(c, nextSolverTime);
		/* Extrapolate inputs */
		extrapolateInputs(model, nextSolverTime);
		/* Set sample hits and call mdlOutputs / mdlUpdate (always a discrete sample time = Fixed-step size) */
		fmi2NewDiscreteStates(c, &(model->eventInfo));
		/* Update solver times */
		lastSolverTime = nextSolverTime;
		model->nbrSolverSteps++;
		nextSolverTime = (model->nbrSolverSteps+1.0)*SFCN_FMI_FIXED_STEP_SIZE;
	}
	model->time = endStepTime;

	return fmi2OK;
}

fmi2Status fmi2CancelStep(fmi2Component c)
{
	Model* model = (Model*) c;

	logger(model, model->instanceName, fmi2Discard, "", "fmi2CancelStep: Not supported since asynchronous execution of fmi2DoStep is not supported\n");
	return fmi2Discard;
}

fmi2Status fmi2GetStatus(fmi2Component c, const fmi2StatusKind s, fmi2Status*  value)
{
	Model* model = (Model*) c;

	logger(model, model->instanceName, fmi2Discard, "", "fmi2GetStatus: Not supported since asynchronous execution of fmi2DoStep is not supported\n");
	return fmi2Discard;
}

fmi2Status fmi2GetRealStatus(fmi2Component c, const fmi2StatusKind s, fmi2Real* value)
{
	Model* model = (Model*) c;

	if (s != fmi2LastSuccessfulTime) {
		logger(model, model->instanceName, fmi2Discard, "", "fmi2GetRealStatus: fmi2StatusKind %d unknown.", s);
		return fmi2Discard;
	}
	*value = model->time;
	return fmi2OK;
}

fmi2Status fmi2GetIntegerStatus(fmi2Component c, const fmi2StatusKind s, fmi2Integer* value)
{
	Model* model = (Model*) c;

	logger(model, model->instanceName, fmi2Discard, "", "fmi2GetIntegerStatus: fmi2StatusKind %d unknown.", s);
	return fmi2Discard;
}

fmi2Status fmi2GetBooleanStatus(fmi2Component c, const fmi2StatusKind s, fmi2Boolean* value)
{
	Model* model = (Model*) c;

	if (s != fmi2Terminated) {
		logger(model, model->instanceName, fmi2Discard, "", "fmi2GetBooleanStatus: fmi2StatusKind %d unknown.", s);
		return fmi2Discard;
	}
	*value = fmi2False;
	return fmi2OK;
}

fmi2Status fmi2GetStringStatus(fmi2Component c, const fmi2StatusKind s, fmi2String*  value)
{
	Model* model = (Model*) c;

	logger(model, model->instanceName, fmi2Discard, "",
			"fmi2GetStringStatus: not supported since asynchronous execution of fmi2DoStep is not supported.");
	return fmi2Discard;
}


/* --------------- SimStruct callback functions to setup dimensions and allocate ports ---------- */

/* Common macro to allocate input port */
#define FMI_INPORT(type, value) {										             \
	int i;																			\
	type** inputPtrs;																\
	type* inputSignals;																\
	inputPtrs    = (type**) allocateMemory0(width, sizeof(type*));					\
	inputSignals = (type*) allocateMemory0(width, sizeof(type));					\
	for (i=0; i<width; i++) {														\
		inputSignals[i] = value;													\
		inputPtrs[i] = &(inputSignals[i]);											\
	}																				\
	arg1->portInfo.inputs[port].signal.ptrs = (InputPtrsType) inputPtrs;							\
}

static int_T SetInputPortDimensionInfoFcn_FMI(SimStruct *arg1, int_T port)
{
	int i;
	void** busInputPtrs;
	void*  busInputObject;
	int_T width = arg1->portInfo.inputs[port].width;

	/* Attempt allocating bus object for port */
	busInputObject = sfcn_fmi_allocateBusObject(1, port, width);
	if (busInputObject != 0) {
		busInputPtrs    = (void**) allocateMemory0(width, sizeof(void*));
		busInputPtrs[0] = busInputObject;
		for (i=1; i<width; i++) {
			busInputPtrs[i] = sfcn_fmi_allocateBusObject(1, port, width);
		}
		arg1->portInfo.inputs[port].signal.ptrs = (InputPtrsType) busInputPtrs;
		return 1;
	}

	/* Allocate port signal vectors */
	switch (arg1->portInfo.inputs[port].dataTypeId) {
		case SS_DOUBLE:   /* real_T    */
			{
				FMI_INPORT(real_T, 0.0);
			}
			break;
		case SS_SINGLE:   /* real32_T  */
			FMI_INPORT(real32_T, 0.0);
			break;
		case SS_INTEGER:  /* int_T */
			{
				FMI_INPORT(int_T, 0);
			}
			break;
		case SS_INT8:     /* int8_T    */
			{
				FMI_INPORT(int8_T, 0);
			}
			break;
		case SS_UINT8:    /* uint8_T   */
			{
				FMI_INPORT(uint8_T, 0);
			}
			break;
		case SS_INT16:    /* int16_T   */
			{
				FMI_INPORT(int16_T, 0);
			}
			break;
		case SS_UINT16:   /* uint16_T  */
			{
				FMI_INPORT(uint16_T, 0);
			}
			break;
		case SS_INT32:    /* int32_T   */
			{
				FMI_INPORT(int32_T, 0);
			}
			break;
		case SS_UINT32:   /* uint32_T  */
			{
				FMI_INPORT(uint32_T, 0);
			}
			break;
		case SS_BOOLEAN:  /* boolean_T */
			{
				FMI_INPORT(boolean_T, false);
			}
			break;
		default:		/* default real_T */
			{
				FMI_INPORT(real_T, 0.0);
			}
			break;
	}

	return 1;
};

static int_T SetOutputPortDimensionInfoFcn_FMI(SimStruct *arg1, int_T port)
{
	void*  busOutputVector;
	int_T width = arg1->portInfo.outputs[port].width;

	/* Attempt allocating bus vector for port */
	busOutputVector = sfcn_fmi_allocateBusObject(0, port, width);
	if (busOutputVector != 0) {
		arg1->portInfo.outputs[port].signalVect = busOutputVector;
		return 1;
	}

	/* Allocate port signal vector */
	switch (arg1->portInfo.outputs[port].dataTypeId) {
		case SS_DOUBLE:   /* real_T    */
			arg1->portInfo.outputs[port].signalVect = (real_T*) allocateMemory0(width, sizeof(real_T));
			break;
		case SS_SINGLE:   /* real32_T  */
			arg1->portInfo.outputs[port].signalVect = (real32_T*) allocateMemory0(width, sizeof(real32_T));
			break;
		case SS_INTEGER:  /* int_T */
			arg1->portInfo.outputs[port].signalVect = (int_T*) allocateMemory0(width, sizeof(int_T));
			break;
		case SS_INT8:     /* int8_T    */
			arg1->portInfo.outputs[port].signalVect = (int8_T*) allocateMemory0(width, sizeof(int8_T));
			break;
		case SS_UINT8:    /* uint8_T   */
			arg1->portInfo.outputs[port].signalVect = (uint8_T*) allocateMemory0(width, sizeof(uint8_T));
			break;
		case SS_INT16:    /* int16_T   */
			arg1->portInfo.outputs[port].signalVect = (int16_T*) allocateMemory0(width, sizeof(int16_T));
			break;
		case SS_UINT16:   /* uint16_T  */
			arg1->portInfo.outputs[port].signalVect = (uint16_T*) allocateMemory0(width, sizeof(uint16_T));
			break;
		case SS_INT32:    /* int32_T   */
			arg1->portInfo.outputs[port].signalVect = (int32_T*) allocateMemory0(width, sizeof(int32_T));
			break;
		case SS_UINT32:   /* uint32_T  */
			arg1->portInfo.outputs[port].signalVect = (uint32_T*) allocateMemory0(width, sizeof(uint32_T));
			break;
		case SS_BOOLEAN:  /* boolean_T */
			arg1->portInfo.outputs[port].signalVect = (boolean_T*) allocateMemory0(width, sizeof(boolean_T));
			break;
		default:
			arg1->portInfo.outputs[port].signalVect = (real_T*) allocateMemory0(width, sizeof(real_T));
			break;
	}

	return 1;
}

static int_T RegNumInputPortsCB_FMI(void *Sptr, int_T nInputPorts)
{
    SimStruct *S = (SimStruct *)Sptr;

    if (nInputPorts < 0) {
        return(0);
    }

    _ssSetNumInputPorts(S,nInputPorts);
    _ssSetSfcnUsesNumPorts(S, 1);

    if (nInputPorts > 0) {
        ssSetPortInfoForInputs(S,
           (struct _ssPortInputs*) allocateMemory0((size_t)nInputPorts,
                                           sizeof(struct _ssPortInputs)));
    }

    return(1);
}

static int_T RegNumOutputPortsCB_FMI(void *Sptr, int_T nOutputPorts)
{
    SimStruct *S = (SimStruct *)Sptr;

    if (nOutputPorts < 0) {
        return(0);
    }

    _ssSetNumOutputPorts(S,nOutputPorts);
    _ssSetSfcnUsesNumPorts(S, 1);

    if (nOutputPorts > 0) {
        ssSetPortInfoForOutputs(S,
            (struct _ssPortOutputs*) allocateMemory0((size_t)nOutputPorts,
                                             sizeof(struct _ssPortOutputs)));
    }

    return(1);
}

static int_T setNumDWork_FMI(SimStruct* S, int_T numDWork)
{
	S->work.dWork.sfcn = (struct _ssDWorkRecord*) allocateMemory0((size_t)numDWork, sizeof(struct _ssDWorkRecord));
	S->sizes.numDWork = numDWork;

	if (S->mdlInfo != NULL) {
		S->mdlInfo->dataTypeAccess = (slDataTypeAccess*) allocateMemory0(1, sizeof(slDataTypeAccess));
		S->mdlInfo->dataTypeAccess->dataTypeTable = (int_T*) allocateMemory0((size_t)numDWork, sizeof(int_T));
	}
	return 1;
}

static DTypeId registerDataTypeFcn_FMI(void * arg1, const char_T * dataTypeName)
{
	int_T i;
	SimStruct* S = (SimStruct*)arg1;

	for (i=0; i<S->sizes.numDWork; i++) {
		if ( ((int_T*)(S->mdlInfo->dataTypeAccess->dataTypeTable))[i] == 0) {
			/* Found next free data type id */
			break;
		}
	}
	return i+15; /* Offset from Simulink built-in data type ids */
}

static int_T setDataTypeSizeFcn_FMI(void * arg1, DTypeId id, int_T size)
{
	SimStruct* S = (SimStruct*)arg1;

	((int_T*)(S->mdlInfo->dataTypeAccess->dataTypeTable))[id-15] = size;
	return 1;
}

/* Setup of port dimensions in stand-alone mode (not including simulink.c) */
int_T _ssSetInputPortMatrixDimensions_FMI(SimStruct *S, int_T port, int_T m, int_T n)
{
    S->portInfo.inputs[port].width     = ((m == DYNAMICALLY_SIZED) || (n == DYNAMICALLY_SIZED))? DYNAMICALLY_SIZED : (m * n);

    return(1);
}

int_T _ssSetOutputPortMatrixDimensions_FMI(SimStruct *S, int_T port, int_T m, int_T n)
{
    S->portInfo.outputs[port].width    = ((m == DYNAMICALLY_SIZED) || (n == DYNAMICALLY_SIZED))? DYNAMICALLY_SIZED : (m * n);

    return(1);
}

int_T _ssSetInputPortVectorDimension_FMI(SimStruct *S, int_T port, int_T m)
{
    S->portInfo.inputs[port].width = m;

    return(1);
}

int_T _ssSetOutputPortVectorDimension_FMI(SimStruct *S, int_T port, int_T m)
{
    S->portInfo.outputs[port].width = m;

    return(1);
}

/* Setup of port dimensions when compiled as MATLAB_MEX_FILE (including simulink.c) */
static int_T SetInputPortWidth_FMI(SimStruct *arg1, int_T port, const DimsInfo_T *dimsInfo)
{
	arg1->portInfo.inputs[port].width = dimsInfo->width;
	return 1;
}
static int_T SetOutputPortWidth_FMI(SimStruct *arg1, int_T port, const DimsInfo_T *dimsInfo)
{
	arg1->portInfo.outputs[port].width = dimsInfo->width;
	return 1;
}

/* ------------------- Allocate SimStruct  -------------------- */

static SimStruct *CreateSimStructForFMI(fmi2String instanceName)
{
	SimStruct *S = (SimStruct*) allocateMemory0(1, sizeof(SimStruct));
	if (S == NULL) {
		return NULL;
	}
	S->mdlInfo = (struct _ssMdlInfo*) allocateMemory0(1, sizeof(struct _ssMdlInfo));
	if (S->mdlInfo == NULL) {
		return NULL;
	}

	_ssSetRootSS(S, S);
    _ssSetSimMode(S, SS_SIMMODE_SIZES_CALL_ONLY);
    _ssSetSFcnParamsCount(S,0);

    _ssSetPath(S,SFCN_FMI_MODEL_IDENTIFIER);
    _ssSetModelName(S,instanceName);

    ssSetRegNumInputPortsFcn(S, RegNumInputPortsCB_FMI);
    ssSetRegNumInputPortsFcnArg(S, (void *)S);
    ssSetRegNumOutputPortsFcn(S, RegNumOutputPortsCB_FMI);
    ssSetRegNumOutputPortsFcnArg(S, (void *)S);
	ssSetRegInputPortDimensionInfoFcn(S, SetInputPortWidth_FMI);
	ssSetRegOutputPortDimensionInfoFcn(S, SetOutputPortWidth_FMI);
	/* Support for custom data types */
	S->regDataType.arg1 = S;
	S->regDataType.registerFcn = registerDataTypeFcn_FMI;
	S->regDataType.setSizeFcn = setDataTypeSizeFcn_FMI;
	/* The following SimStruct initialization is required for use with RTW-generated S-functions */
	S->mdlInfo->simMode = SS_SIMMODE_NORMAL;
	S->mdlInfo->variableStepSolver = SFCN_FMI_IS_VARIABLE_STEP_SOLVER;
	S->mdlInfo->fixedStepSize = SFCN_FMI_FIXED_STEP_SIZE;
	S->mdlInfo->stepSize = SFCN_FMI_FIXED_STEP_SIZE;						/* Step size used by ODE solver */
	S->mdlInfo->solverMode = (SFCN_FMI_IS_MT == 1) ? SOLVER_MODE_MULTITASKING : SOLVER_MODE_SINGLETASKING;
	S->mdlInfo->solverExtrapolationOrder = SFCN_FMI_EXTRAPOLATION_ORDER;	/* Extrapolation order for ode14x */
	S->mdlInfo->solverNumberNewtonIterations = SFCN_FMI_NEWTON_ITER;		/* Number of iterations for ode14x */
	S->mdlInfo->simTimeStep = MAJOR_TIME_STEP; /* Make ssIsMajorTimeStep return true during initialization */
	S->sfcnParams.dlgNum = 0;  /* No dialog parameters, check performed in mdlInitializeSizes */
	S->errorStatus.str = NULL; /* No error */
	S->blkInfo.block = NULL;   /* Accessed by ssSetOutputPortBusMode in mdlInitializeSizes */
	S->regDataType.setNumDWorkFcn = setNumDWork_FMI;

#if defined(MATLAB_R2011a_) || defined(MATLAB_R2015a_) || defined(MATLAB_R2017b_)
	S->states.statesInfo2 = (struct _ssStatesInfo2 *) allocateMemory0(1, sizeof(struct _ssStatesInfo2));
#if defined(MATLAB_R2015a_) || defined(MATLAB_R2017b_)
	S->states.statesInfo2->periodicStatesInfo = (ssPeriodicStatesInfo *) allocateMemory0(1, sizeof(ssPeriodicStatesInfo));
#endif
#endif

    return(S);
}

static void allocateSimStructVectors(Model* m) {
	int_T i;
	SimStruct* S = m->S;

	S->states.contStates        = (real_T*) allocateMemory0(S->sizes.numContStates+1, sizeof(real_T));
	S->states.dX				= (real_T*) allocateMemory0(S->sizes.numContStates+1, sizeof(real_T));
	/* Store pointer, since it will be changed to point to ODE integration data */
	m->dX						= S->states.dX;
	S->states.contStateDisabled = (boolean_T*) allocateMemory0(S->sizes.numContStates+1, sizeof(boolean_T));
	S->states.discStates        = (real_T*) allocateMemory0(S->sizes.numDiscStates+1, sizeof(real_T));
#if defined(MATLAB_R2011a_) || defined(MATLAB_R2015a_) || defined(MATLAB_R2017b_)
	S->states.statesInfo2->absTol = (real_T*) allocateMemory0(S->sizes.numContStates+1, sizeof(real_T));
	S->states.statesInfo2->absTolControl = (uint8_T*) allocateMemory0(S->sizes.numContStates+1, sizeof(uint8_T));
#endif
	S->stInfo.sampleTimes       = (time_T*) allocateMemory0(S->sizes.numSampleTimes+1, sizeof(time_T));
	S->stInfo.offsetTimes       = (time_T*) allocateMemory0(S->sizes.numSampleTimes+1, sizeof(time_T));
	S->stInfo.sampleTimeTaskIDs = (int_T*)  allocateMemory0(S->sizes.numSampleTimes+1, sizeof(int_T));
	/* Allocating per-task sample hit matrix */
	S->mdlInfo->sampleHits      = (int_T*)  allocateMemory0(S->sizes.numSampleTimes*S->sizes.numSampleTimes+1, sizeof(int_T));
	S->mdlInfo->perTaskSampleHits = S->mdlInfo->sampleHits;
	S->mdlInfo->t               = (time_T*) allocateMemory0(S->sizes.numSampleTimes+1, sizeof(time_T));
	S->work.modeVector          = (int_T*)  allocateMemory0(S->sizes.numModes+1, sizeof(int_T));
	S->work.iWork               = (int_T*)  allocateMemory0(S->sizes.numIWork+1, sizeof(int_T));
	S->work.pWork               = (void**)  allocateMemory0(S->sizes.numPWork+1, sizeof(void*));
	S->work.rWork               = (real_T*) allocateMemory0(S->sizes.numRWork+1, sizeof(real_T));
	for (i=0;i<S->sizes.in.numInputPorts;i++) {
		SetInputPortDimensionInfoFcn_FMI(S, i);
	}
	for (i=0;i<S->sizes.out.numOutputPorts;i++) {
		SetOutputPortDimensionInfoFcn_FMI(S, i);
	}
	for (i=0;i<S->sizes.numDWork;i++) {
		switch (S->work.dWork.sfcn[i].dataTypeId) {
			case SS_DOUBLE:   /* real_T    */
				S->work.dWork.sfcn[i].array = (real_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(real_T));
				break;
			case SS_SINGLE:   /* real32_T  */
				S->work.dWork.sfcn[i].array = (real32_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(real32_T));
				break;
			case SS_INTEGER:  /* int_T */
				S->work.dWork.sfcn[i].array = (int_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(int_T));
				break;
			case SS_INT8:     /* int8_T    */
				S->work.dWork.sfcn[i].array = (int8_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(int8_T));
				break;
			case SS_UINT8:    /* uint8_T   */
				S->work.dWork.sfcn[i].array = (uint8_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(uint8_T));
				break;
			case SS_INT16:    /* int16_T   */
				S->work.dWork.sfcn[i].array = (int16_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(int16_T));
				break;
			case SS_UINT16:   /* uint16_T  */
				S->work.dWork.sfcn[i].array = (uint16_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(uint16_T));
				break;
			case SS_INT32:    /* int32_T   */
				S->work.dWork.sfcn[i].array = (int32_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(int32_T));
				break;
			case SS_UINT32:   /* uint32_T  */
				S->work.dWork.sfcn[i].array = (uint32_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(uint32_T));
				break;
			case SS_BOOLEAN:  /* boolean_T */
				S->work.dWork.sfcn[i].array = (boolean_T*) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(boolean_T));
				break;
			case SS_POINTER:  /* void* */
				S->work.dWork.sfcn[i].array = (void**) allocateMemory0(S->work.dWork.sfcn[i].width, sizeof(void*));
				break;
			default:  /* Custom data type registered */
				S->work.dWork.sfcn[i].array = (void*) allocateMemory0(S->work.dWork.sfcn[i].width, ((int_T*)(S->mdlInfo->dataTypeAccess->dataTypeTable))[S->work.dWork.sfcn[i].dataTypeId-15]);
				break;
		}
	}
}

static void resetSimStructVectors(SimStruct *S)
{
	int_T i;

	memset(S->states.contStates,					0, (S->sizes.numContStates+1)*sizeof(real_T));
	memset(S->states.dX,							0, (S->sizes.numContStates+1)*sizeof(real_T));
	memset(S->states.contStateDisabled,				0, (S->sizes.numContStates+1)*sizeof(boolean_T));
	memset(S->states.discStates,					0, (S->sizes.numDiscStates+1)*sizeof(real_T));
	memset(S->stInfo.sampleTimes,					0, (S->sizes.numSampleTimes+1)*sizeof(time_T));
	memset(S->stInfo.offsetTimes,					0, (S->sizes.numSampleTimes+1)*sizeof(time_T));
	memset(S->stInfo.sampleTimeTaskIDs,				0, (S->sizes.numSampleTimes+1)*sizeof(int_T));
	memset(S->mdlInfo->sampleHits,					0, (S->sizes.numSampleTimes*S->sizes.numSampleTimes+1)*sizeof(int_T));
	memset(S->mdlInfo->t,							0, (S->sizes.numSampleTimes+1)*sizeof(time_T));
	memset(S->work.modeVector,						0, (S->sizes.numModes+1)*sizeof(int_T));
	memset(S->work.iWork,							0, (S->sizes.numIWork+1)*sizeof(int_T));
	memset(S->work.pWork,							0, (S->sizes.numPWork+1)*sizeof(void*));
	memset(S->work.rWork,							0, (S->sizes.numRWork+1)*sizeof(real_T));
	memset(S->mdlInfo->solverInfo->zcSignalVector,	0, (SFCN_FMI_ZC_LENGTH+1)*sizeof(real_T));
	for (i=0;i<S->sizes.numDWork;i++) {
		switch (S->work.dWork.sfcn[i].dataTypeId) {
			case SS_DOUBLE:   /* real_T    */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(real_T));
				break;
			case SS_SINGLE:   /* real32_T  */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(real32_T));
				break;
			case SS_INTEGER:  /* int_T */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(int_T));
				break;
			case SS_INT8:     /* int8_T    */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(int8_T));
				break;
			case SS_UINT8:    /* uint8_T   */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(uint8_T));
				break;
			case SS_INT16:    /* int16_T   */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(int16_T));
				break;
			case SS_UINT16:   /* uint16_T  */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(uint16_T));
				break;
			case SS_INT32:    /* int32_T   */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(int32_T));
				break;
			case SS_UINT32:   /* uint32_T  */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(uint32_T));
				break;
			case SS_BOOLEAN:  /* boolean_T */
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(boolean_T));
				break;
			default:
				memset(S->work.dWork.sfcn[i].array, 0, (S->work.dWork.sfcn[i].width)*sizeof(real_T));
				break;
		}
	}
}

static void setSampleStartValues(Model* m)
{
	int i;

	m->fixed_in_minor_step_offset_tid = -1;
	for (i=0;i<m->S->sizes.numSampleTimes;i++) {
		m->S->stInfo.sampleTimeTaskIDs[i] = i; /* Simple mapping, only considering root SimStruct for the moment */
		m->S->mdlInfo->t[i] = m->S->stInfo.offsetTimes[i];
		if (m->S->stInfo.sampleTimes[i] < SFCN_FMI_EPS) {
			if (m->S->stInfo.offsetTimes[i] < FIXED_IN_MINOR_STEP_OFFSET - SFCN_FMI_EPS) {
				m->S->mdlInfo->sampleHits[i] = 1;		/* Continuous sample time */
			} else {
				m->fixed_in_minor_step_offset_tid = i;	/* FIXED_IN_MINOR_STEP_OFFSET */
			}
		} else {
			if (i==0) {
				m->isDiscrete = fmi2True;			/* Purely discrete */
			}
		}
	}
	if (SFCN_FMI_LOAD_MEX) {
		copyPerTaskSampleHits(m->S);
	}
}

static void FreeSimStruct(SimStruct *S, const fmi2CallbackFunctions *functions) {
	int_T port, i;
	void** inputPtrs;
	void* inputSignals;

	if (S != NULL) {

		for (port=0;port<S->sizes.in.numInputPorts;port++) {
			inputPtrs = (void**)S->portInfo.inputs[port].signal.ptrs;
			if (inputPtrs != NULL) {
				inputSignals = inputPtrs[0];
				sfcn_fmi_FREE(inputSignals, functions->freeMemory);
				functions->freeMemory(inputPtrs);
				inputPtrs = NULL;
			}
		}
		sfcn_fmi_FREE(S->portInfo.inputs, functions->freeMemory);

		for (port=0;port<S->sizes.out.numOutputPorts;port++) {
			sfcn_fmi_FREE(S->portInfo.outputs[port].signalVect, functions->freeMemory);
		}
		sfcn_fmi_FREE(S->portInfo.outputs, functions->freeMemory);

		sfcn_fmi_FREE(S->states.contStates, functions->freeMemory);
		/* S->states.dX changed and deallocated by rt_DestroyIntegrationData */
		sfcn_fmi_FREE(S->states.contStateDisabled, functions->freeMemory);
		sfcn_fmi_FREE(S->states.discStates, functions->freeMemory);
		sfcn_fmi_FREE(S->stInfo.sampleTimes, functions->freeMemory);
		sfcn_fmi_FREE(S->stInfo.offsetTimes, functions->freeMemory);
		sfcn_fmi_FREE(S->stInfo.sampleTimeTaskIDs, functions->freeMemory);
		sfcn_fmi_FREE(S->work.modeVector, functions->freeMemory);
		sfcn_fmi_FREE(S->work.iWork, functions->freeMemory);
		sfcn_fmi_FREE(S->work.pWork, functions->freeMemory);
		sfcn_fmi_FREE(S->work.rWork, functions->freeMemory);
		for (i=0;i<S->sizes.numDWork;i++) {
			sfcn_fmi_FREE(S->work.dWork.sfcn[i].array, functions->freeMemory);
		}
		sfcn_fmi_FREE(S->work.dWork.sfcn, functions->freeMemory);
		sfcn_fmi_mxGlobalTunable_(S, 0, 0);
		sfcn_fmi_FREE(S->sfcnParams.dlgParams, functions->freeMemory);

#if defined(MATLAB_R2011a_) || defined(MATLAB_R2015a_) || defined(MATLAB_R2017b_)
		sfcn_fmi_FREE(S->states.statesInfo2->absTol, functions->freeMemory);
		sfcn_fmi_FREE(S->states.statesInfo2->absTolControl, functions->freeMemory);
#if defined(MATLAB_R2015a_) || defined(MATLAB_R2017b_)
		sfcn_fmi_FREE(S->states.statesInfo2->periodicStatesInfo, functions->freeMemory);
#endif
		sfcn_fmi_FREE(S->states.statesInfo2, functions->freeMemory);
#endif

		if (S->mdlInfo != NULL) {
			if (S->mdlInfo->dataTypeAccess != NULL) {
				sfcn_fmi_FREE(S->mdlInfo->dataTypeAccess->dataTypeTable, functions->freeMemory);
				functions->freeMemory(S->mdlInfo->dataTypeAccess);
				S->mdlInfo->dataTypeAccess = NULL;
		 	}
			sfcn_fmi_FREE(S->mdlInfo->solverInfo->zcSignalVector, functions->freeMemory);
			sfcn_fmi_FREE(S->mdlInfo->sampleHits, functions->freeMemory);
			sfcn_fmi_FREE(S->mdlInfo->t, functions->freeMemory);
			rt_DestroyIntegrationData(S); /* Clear solver data */
			functions->freeMemory(S->mdlInfo);
			S->mdlInfo = NULL;
		}

		functions->freeMemory(S);
		S = NULL;
	}
}


/* ----------------- Local function definitions ----------------- */

/* Most FMI environments pass in calloc, but zero initialization was
   not guaranteed in early versions of FMI */
void* allocateMemory0(size_t nobj, size_t size) {

	void* obj;
	if (allocateMemory == NULL) {
		return NULL;
	} else {
		obj = allocateMemory(nobj, size);
		memset(obj, 0, nobj*size);
		return obj;
	}
}

static void logger(fmi2Component c, fmi2String instanceName, fmi2Status status,
				   fmi2String category, fmi2String message, ...)
{
	char buf[4096];
	va_list ap;
    int capacity;
	Model* model;

	if (c==NULL) return;

	model = (Model*) c;
	if (model->loggingOn == fmi2False && (status == fmi2OK || status == fmi2Discard)) {
		return;
	}

	va_start(ap, message);
    capacity = sizeof(buf) - 1;
#if defined(_MSC_VER) && _MSC_VER>=1400
	vsnprintf_s(buf, capacity, _TRUNCATE, message, ap);
#else
    buf[capacity]=0;
	vsnprintf(buf, capacity, message, ap);
#endif
	va_end(ap);
	model->functions->logger(model->functions->componentEnvironment, instanceName, status, category, buf);
}

static fmi2String strDup(const fmi2CallbackFunctions *functions, fmi2String s)
{
	const fmi2String nullString = "<NULL>";
	const int maxLen = 1024;
	fmi2String pos = s;
	int len;
	char* newS;

	if (s == NULL) {
		s = nullString;
	}
	len = (int) strlen(s);
	if (len > maxLen) {
		len = maxLen;
	}

	newS = (char*) allocateMemory0(len + 1, sizeof(char));
	if (newS == NULL) {
		return NULL;
	}
	strncpy(newS, s, len);
	return newS;
}

/* FMU mapping of ssPrintf for child C source S-functions (through rtPrintfNoOp) */
int rtPrintfNoOp(const char *fmt, ...)
{
	char buf[4096];
	va_list ap;
    int capacity;

	if (currentModel==NULL) return -1;

	va_start(ap, fmt);
    capacity = sizeof(buf) - 1;
#if defined(_MSC_VER) && _MSC_VER>=1400
	vsnprintf_s(buf, capacity, _TRUNCATE, fmt, ap);
#else
    buf[capacity]=0;
	vsnprintf(buf, capacity, fmt, ap);
#endif
	va_end(ap);
	logger(currentModel, currentModel->instanceName, fmi2OK, "", buf);

    return 0;
}

/* Wrapper function to be called from C++ implementation of rtPrintfNoOp */
int rtPrintfNoOp_C(const char *fmt, ...)
{
	char buf[4096];
	va_list ap;
    int capacity;

	if (currentModel==NULL) return -1;

	va_start(ap, fmt);
    capacity = sizeof(buf) - 1;
#if defined(_MSC_VER) && _MSC_VER>=1400
	vsnprintf_s(buf, capacity, _TRUNCATE, fmt, ap);
#else
    buf[capacity]=0;
	vsnprintf(buf, capacity, fmt, ap);
#endif
	va_end(ap);
	logger(currentModel, currentModel->instanceName, fmi2OK, "", buf);

    return 0;
}

/* Dynamic loading of MATLAB MEX files for S-function blocks */
int LoadMEXAndDependencies(Model *model)
{
#if defined(_MSC_VER)
	HINSTANCE hInst;
	HMODULE hMySelf=0;
#else
	Dl_info dli;
	struct stat sb;
	void* hInst = NULL;
#endif
	int i;
	char fmuPath[1024];
	char*last;
	char*mexDir;
	char mexFile[1024];

#if defined(_MSC_VER)
	/* Setting MATLAB bin directory and loading MATLAB dependencies.
		Not done on Linux, there the MATLAB bin needs to be set with LD_LIBRARY_PATH */
	if ( (getenv("SFCN_FMI_MATLAB_BIN") != NULL) && (_SFCN_FMI_MATLAB_BIN == NULL) ) {
		_SFCN_FMI_MATLAB_BIN = strDup(model->functions, getenv("SFCN_FMI_MATLAB_BIN"));
	}
	if (_SFCN_FMI_MATLAB_BIN == NULL) {
		SetDllDirectory(SFCN_FMI_MATLAB_BIN);
		logger(model, model->instanceName, fmi2OK, "", "Setting DLL directory for MATLAB dependencies: %s", SFCN_FMI_MATLAB_BIN);
		logger(model, model->instanceName, fmi2OK, "", "The environment variable SFCN_FMI_MATLAB_BIN can be used to override this path.");
	} else {
		SetDllDirectory(_SFCN_FMI_MATLAB_BIN);
		logger(model, model->instanceName, fmi2OK, "", "Setting DLL directory for MATLAB dependencies: %s", _SFCN_FMI_MATLAB_BIN);
		logger(model, model->instanceName, fmi2OK, "", "Environment variable SFCN_FMI_MATLAB_BIN was used to override default path.");
	}
	logger(model, model->instanceName, fmi2OK, "", "Loading from MATLAB bin...");
	if (hInst=LoadLibraryA("libmx.dll")) {
		logger(model, model->instanceName, fmi2OK, "", "...libmx.dll");
	} else  {
		logger(model, model->instanceName, fmi2Error, "", "Failed to load binary libmx.dll\n");
		return 0;
	}
	if (hInst=LoadLibraryA("libmex.dll")) {
		logger(model, model->instanceName, fmi2OK, "", "...libmex.dll");
	} else  {
		logger(model, model->instanceName, fmi2Error, "", "Failed to load binary libmex.dll\n");
		return 0;
	}
	if (hInst=LoadLibraryA("libmat.dll")) {
		logger(model, model->instanceName, fmi2OK, "", "...libmat.dll");
	} else  {
		logger(model, model->instanceName, fmi2Error, "", "Failed to load binary libmat.dll\n");
		return 0;
	}
	if (hInst=LoadLibraryA("libfixedpoint.dll")) {
		logger(model, model->instanceName, fmi2OK, "", "...libfixedpoint.dll");
	} else  {
		logger(model, model->instanceName, fmi2Error, "", "Failed to load binary libfixedpoint.dll\n");
		return 0;
	}
	if (hInst=LoadLibraryA("libut.dll")) {
		logger(model, model->instanceName, fmi2OK, "", "...libut.dll");
	} else  {
		logger(model, model->instanceName, fmi2Error, "", "Failed to load binary libut.dll\n");
		return 0;
	}
	hMySelf=GetModuleHandleA(SFCN_FMI_MODEL_IDENTIFIER);
	if (GetModuleFileNameA(hMySelf, fmuPath, sizeof(fmuPath)/sizeof(*fmuPath))==0) {
#else
	if (dladdr(__builtin_return_address(0), &dli) != 0 && dli.dli_fname != NULL) {
		strcpy(fmuPath, dli.dli_fname);
	} else {
#endif
		logger(model, model->instanceName, fmi2Fatal, "", "Failed to retrieve module file name for %s\n", SFCN_FMI_MODEL_IDENTIFIER);
		return 0;
	}
	fmuPath[sizeof(fmuPath)/sizeof(*fmuPath)-1]=0; /* Make sure it is NUL-terminated */
	last=strrchr(fmuPath,'\\');
	if (last==0) last=strrchr(fmuPath,'/');
	if (last) {
		last[0]=0;
		last=strrchr(fmuPath,'\\');
		if (last==0) last=strrchr(fmuPath,'/');
		if (last) {
			last[0]=0;
			last=strrchr(fmuPath,'\\');
			if (last==0) last=strrchr(fmuPath,'/');
		}
	}
	if (last) last[1]=0;
#if defined(_MSC_VER)
	mexDir = strcat(fmuPath,"resources\\SFunctions\\");
#else
	mexDir = strcat(fmuPath,"resources/SFunctions/");
#endif
	for (i=0; i<SFCN_FMI_NBR_MEX; i++) {
		if (i==0) {
			logger(model, model->instanceName, fmi2OK, "", "Loading S-function MEX files from FMU resources...");
#if defined(_MSC_VER)
			SetDllDirectory(mexDir); /* To handle dependencies to other DLLs in the same folder */
#endif
		}
		strncpy(mexFile, mexDir, strlen(mexDir)+1);
		strcat(mexFile, SFCN_FMI_MEX_NAMES[i]);
#if defined(_MSC_VER)
		if (hInst=LoadLibraryA(mexFile)) {
#else
		if (stat(mexFile, &sb) == 0) {
			hInst = dlopen(mexFile, RTLD_NOW);
			if (hInst != NULL) {
#endif
				model->mexHandles[i]=hInst;
				logger(model, model->instanceName, fmi2OK, "", "...%s", SFCN_FMI_MEX_NAMES[i]);
			} else  {
				logger(model, model->instanceName, fmi2Error, "", "Failed to load binary MEX file: %s", SFCN_FMI_MEX_NAMES[i]);
				return 0;
			}
#if !defined(_MSC_VER)
		}
#endif
	}
	return 1;
}

typedef void (*mexFunctionPtr) (int_T nlhs, mxArray *plhs[], int_T nrhs, const mxArray *prhs[]);

static int sfcn_fmi_load_mex(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[], const char *functionName, const char* mexext)
{
	int i;
	char mexName[256];
    mexFunctionPtr mexFunc = NULL;
#if defined(_MSC_VER)
	HINSTANCE hInst = 0;
#else
	void* hInst = 0;
#endif

	sprintf(mexName, "%s.%s", functionName, mexext);
	/* Find handle index */
	for (i=0; i<SFCN_FMI_NBR_MEX; i++) {
		if (strcmp(mexName, SFCN_FMI_MEX_NAMES[i]) == 0) {
			break;
		}
	}
	if (i<SFCN_FMI_NBR_MEX) {
		hInst = currentModel->mexHandles[i];
	}
    if (hInst) {
#if defined(_MSC_VER)
		mexFunc = (mexFunctionPtr)GetProcAddress(hInst,"mexFunction");
		if (mexFunc == NULL) {
			mexFunc = (mexFunctionPtr)GetProcAddress(hInst,"_mexFunction");
		}
#else
		mexFunc = (mexFunctionPtr) dlsym(hInst,"mexFunction");
		if (mexFunc == NULL) {
			mexFunc = (mexFunctionPtr) dlsym(hInst,"_mexFunction"); /* probably not needed here, only LCC generates entrypoint _mexFunction */
		}
#endif
		if (mexFunc) {
			logger(currentModel, currentModel->instanceName, fmi2OK, "", "Calling MEX S-function: %s", mexName);
			mexFunc(nlhs, plhs, nrhs, (const mxArray**)prhs);
			if (currentModel->S != NULL) {
				if (ssGetErrorStatus(currentModel->S) != NULL) {
					logger(currentModel, currentModel->instanceName, fmi2Fatal, "",
						"Error in S-function (mdlInitializeSizes): %s\n", ssGetErrorStatus(currentModel->S));
					return 1;
				}
			}
		} else {
			logger(currentModel, currentModel->instanceName, fmi2Fatal, "", "Failed to retrieve 'mexFunction' entry point from %s\n", mexName);
			return 1;
		}
	} else  {
		logger(currentModel, currentModel->instanceName, fmi2Fatal, "", "Failed to retrieve handle to call binary MEX file: %s", mexName);
		return 1;
	}

	return 0;
}

int sfcn_fmi_load_mexw32(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[], const char *functionName)
{
	return sfcn_fmi_load_mex(nlhs, plhs, nrhs, prhs, functionName, "mexw32");
}

int sfcn_fmi_load_mexw64(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[], const char *functionName)
{
	return sfcn_fmi_load_mex(nlhs, plhs, nrhs, prhs, functionName, "mexw64");
}

int sfcn_fmi_load_mexglx(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[], const char *functionName)
{
	return sfcn_fmi_load_mex(nlhs, plhs, nrhs, prhs, functionName, "mexglx");
}

int sfcn_fmi_load_mexa64(int nlhs, mxArray *plhs[], int nrhs, mxArray *prhs[], const char *functionName)
{
	return sfcn_fmi_load_mex(nlhs, plhs, nrhs, prhs, functionName, "mexa64");
}
